{"version":3,"file":"index.cjs","sources":["../src/DefaultIPFSResolver.ts","../src/DefaultIssuerResolver.ts","../src/DefaultWebFingerResolver.ts","../src/MemoryDomainResolver.ts","../src/MemoryWebFingerResolver.ts","../src/JRD.ts"],"sourcesContent":["import {IPFSResolver} from './types'\n\nexport default class DefaultIPFSResolver implements IPFSResolver {\n  static defaultCreateUrl(cid: string, path: string): string {\n    return `https://${cid}.ipns.dweb.link${path.replace(/^\\/?/, '/')}`\n  }\n\n  constructor(public createURL = DefaultIPFSResolver.defaultCreateUrl) {}\n\n  async resolve(uri: string): Promise<string> {\n    let cid: string\n    let path: string\n    let protocol: string\n\n    if (uri.startsWith('/ipfs/') || uri.startsWith('/ipns/')) {\n      protocol = uri.substring(1, 5)\n      cid = uri.substring(6).split('/')[0]\n      path = uri.substring(6 + cid.length)\n    } else {\n      const url = new URL(uri)\n\n      if (\n        url.hash !== '' ||\n        url.password !== '' ||\n        url.port !== '' ||\n        url.search !== '' ||\n        url.username !== ''\n      ) {\n        throw new Error('invalid ipfs uri')\n      }\n\n      protocol = url.protocol.substring(0, 4)\n      cid = url.hostname\n      path = url.pathname\n    }\n\n    if (protocol !== 'ipfs') {\n      throw new Error('only ipfs is supported, (not ipns)')\n    }\n\n    return fetch(this.createURL(cid, path)).then(resp =>\n      resp.ok ? resp.text() : Promise.reject(new Error('bad response')),\n    )\n  }\n}\n","import {IssuerResolver, IssuerResolverOptions} from './types'\n\nexport default class DefaultIssuerResolver implements IssuerResolver {\n  constructor(public options: IssuerResolverOptions) {}\n\n  async resolve(username: string, fallbackIssuer: string) {\n    let user = ''\n    let domain: string\n    if (username.includes('@')) {\n      ;[user, domain] = username.split('@', 1)\n    } else {\n      domain = username\n    }\n\n    const rel = 'http://openid.net/specs/connect/1.0/issuer'\n\n    const jrd = await this.options.webfingerResolver.resolve(\n      domain,\n      user,\n      rel,\n      fallbackIssuer,\n    )\n\n    const link = jrd.links?.find(v => v.rel === rel)\n    if (!link || !link.href) {\n      throw new Error('bad jrd')\n    }\n\n    const config = await fetch(\n      link.href + '/.well-known/openid-configuration',\n    ).then(resp =>\n      resp.ok\n        ? resp.json()\n        : Promise.reject(new Error('bad openid-configuration response')),\n    )\n\n    return config\n  }\n}\n","import {isJRD} from './JRD'\nimport {JRDDocument, WebFingerRecord, WebFingerResolverOptions} from './types'\n\nexport default class DefaultWebFingerResolver {\n  constructor(public options: WebFingerResolverOptions) {}\n\n  async resolve(\n    domain: string,\n    user: string,\n    rel: string,\n    fallbackIssuer: string,\n  ): Promise<JRDDocument> {\n    const webfingerKey = `webfinger.${user}.${rel}`\n\n    // console.log('domain:', domain)\n    // console.log('webfingerKey:', webfingerKey)\n\n    const records = await this.options.domainResolver.records(domain, [\n      webfingerKey,\n    ])\n\n    const resource = user ? `acct:${user}@${domain}` : `${domain}`\n\n    // console.log('record value:', records[webfingerKey])\n\n    if (!records[webfingerKey]) {\n      return {subject: resource, links: [{rel, href: fallbackIssuer}]}\n    }\n\n    const webfingerRecord: WebFingerRecord = JSON.parse(records[webfingerKey])\n\n    // console.log('webfingerRecord:', webfingerRecord)\n\n    let json\n    if (typeof webfingerRecord.host === 'string') {\n      json = await fetch(\n        '/.well-known/webfinger?' +\n          new URLSearchParams({resource, rel}).toString(),\n        {headers: {Host: webfingerRecord.host}},\n      ).then(resp =>\n        resp.ok\n          ? resp.json()\n          : Promise.reject(new Error('bad webfinger response')),\n      )\n    } else if (typeof webfingerRecord.uri === 'string') {\n      const url = new URL(webfingerRecord.uri)\n\n      switch (url.protocol) {\n        case 'http:':\n        case 'https:': {\n          json = await fetch(url.toString()).then(resp =>\n            resp.ok\n              ? resp.json()\n              : Promise.reject(new Error('bad webfinger response')),\n          )\n          break\n        }\n        case 'ipfs:': {\n          json = JSON.parse(\n            await this.options.ipfsResolver.resolve(webfingerRecord.uri),\n          )\n          break\n        }\n        case 'ipns:':\n        case 'swarm:':\n        default: {\n          throw new Error('uri scheme not supported')\n        }\n      }\n    } else if (typeof webfingerRecord.value === 'string') {\n      json = JSON.parse(webfingerRecord.value)\n    } else {\n      throw new Error('bad webfinger record')\n    }\n\n    if (!isJRD(json)) {\n      throw new Error('resolved document not jrd')\n    }\n\n    if (json.subject !== resource) {\n      throw new Error('resource invalid')\n    }\n\n    return json\n  }\n}\n","import {DomainResolver} from './types'\n\nexport default class MemoryDomainResolver implements DomainResolver {\n  private map: Map<string, Record<string, string>> = new Map()\n\n  set(domain: string, records: Record<string, string>): void {\n    if (!this.map.has(domain)) {\n      this.map.set(domain, records)\n      return\n    }\n\n    this.map.set(domain, {...this.map.get(domain), ...records})\n  }\n\n  records = async (\n    domain: string,\n    keys: string[],\n  ): Promise<Record<string, string>> => {\n    const records = this.map.get(domain)\n\n    if (keys.length === 0) {\n      throw new Error('no keys')\n    }\n\n    if (!records) {\n      return {}\n    }\n\n    return keys.reduce((a, v) => {\n      a[v] = records[v] || ''\n      return a\n    }, {} as Record<string, string>)\n  }\n}\n","import {JRDDocument, WebFingerResolver} from './types'\n\nexport default class MemoryWebFingerResolver implements WebFingerResolver {\n  map = new Map<string, JRDDocument>()\n\n  set(domain: string, user: string, rel: string, document: JRDDocument): void {\n    this.map.set(`${domain}.${user}.${rel}`, document)\n  }\n\n  async resolve(\n    domain: string,\n    user: string,\n    rel: string,\n    fallbackIssuer: string,\n  ): Promise<JRDDocument> {\n    const jrd = this.map.get(`${domain}.${user}.${rel}`)\n\n    if (!jrd) {\n      return {subject: domain, links: [{rel, href: fallbackIssuer}]}\n    }\n\n    return jrd\n  }\n}\n","import {JRDDocument, JRDLink} from './types'\n\nexport function isJRDLink(json: any): json is JRDLink {\n  return true\n}\n\nexport function isJRD(json: any): json is JRDDocument {\n  return true\n}\n"],"names":["DefaultIPFSResolver","defaultCreateUrl","createURL","this","cid","path","replace","resolve","uri","protocol","startsWith","substring","split","length","url","URL","hash","password","port","search","username","Error","hostname","pathname","Promise","fetch","then","resp","ok","text","reject","DefaultIssuerResolver","options","fallbackIssuer","domain","user","includes","_username$split","rel","webfingerResolver","jrd","_jrd$links","link","links","find","v","href","json","pact","state","value","s","o","_settle","bind","observer","DefaultWebFingerResolver","_this2","webfingerKey","domainResolver","records","subject","resource","webfingerRecord","JSON","parse","_temp","host","URLSearchParams","toString","headers","Host","_fetch$then","_switch","_fetch$then2","ipfsResolver","_this$options$ipfsRes","_temp2","e","_Pact","prototype","onFulfilled","onRejected","result","callback","_this","MemoryDomainResolver","map","Map","keys","get","reduce","a","set","has","_extends","MemoryWebFingerResolver","document"],"mappings":"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"}