import { DomainResolver, IssuerResolver, Authorization, AuthorizationEndpointResponse } from '@uauth/common';
import type { Request, Response, NextFunction } from 'express';
interface Interaction {
    state: string;
    nonce: string;
    verifier: string;
    tokenEndpoint: string;
    jwksUri?: string;
    jwks?: string;
}
declare module 'express-session' {
    interface SessionData {
        [key: string]: any;
    }
}
interface Locals {
    [key: string]: any;
}
declare module 'express' {
    interface Response {
        locals: Locals;
    }
}
interface ClientOptions {
    clientID: string;
    clientSecret: string;
    scope: string;
    redirectUri: string;
    maxAge: number;
    clockSkew: number;
    audience?: string;
    resolution: DomainResolver;
    fallbackIssuer: string;
    createIpfsUrl: (cid: string, path: string) => string;
}
declare type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
export declare type ClientConstructorOptions = Optional<ClientOptions, 'fallbackIssuer' | 'scope' | 'maxAge' | 'clockSkew' | 'createIpfsUrl'>;
interface BuildAuthorizationUrlAndInteractionOptions {
    username: string;
}
interface LoginOptions extends BuildAuthorizationUrlAndInteractionOptions {
    beforeRedirect?(options: LoginOptions, url: string): Promise<void> | void;
}
interface ExpressSessionLogin {
    login: (req: Request, res: Response, next: NextFunction, options: LoginOptions) => Promise<void>;
    callback: (req: Request, res: Response, next: NextFunction) => Promise<Authorization>;
    middleware: (scopes?: string[]) => (req: Request, res: Response, next: NextFunction) => void;
}
declare class Client {
    options: ClientOptions;
    issuerResolver: IssuerResolver;
    constructor(options: ClientConstructorOptions);
    createExpressSessionLogin(sessionKey?: string, localsKey?: string): ExpressSessionLogin;
    formatUrlSearchParams(endpoint: string, params: Record<string, string>): string;
    buildAuthorizationUrlAndInteraction(options: BuildAuthorizationUrlAndInteractionOptions): Promise<{
        url: string;
        interaction: Interaction;
    }>;
    authorizationCodeGrantExchange(interaction: Interaction, authorizationEndpointResponse: AuthorizationEndpointResponse): Promise<Authorization>;
    validateAuthorization(authorization: Authorization | undefined, scopes?: string[]): void;
    createLogin<T>(actions: {
        storeInteraction: (ctx: T, interaction: Interaction) => void | Promise<void>;
        retrieveInteraction: (ctx: T) => Interaction | undefined | Promise<Interaction | undefined>;
        deleteInteraction: (ctx: T) => void | Promise<void>;
        storeAuthorization: (ctx: T, authorization: Authorization) => void | Promise<void>;
        retrieveAuthorization: (ctx: T) => Authorization | undefined | Promise<Authorization | undefined>;
        deleteAuthorization: (ctx: T) => void | Promise<void>;
        retrieveAuthorizationEndpointResponse: (ctx: T) => AuthorizationEndpointResponse;
        passOnAuthorization: (ctx: T, authorization: Authorization) => void;
        redirect: (ctx: T, url: string) => void | Promise<void>;
    }): {
        login(ctx: T, options: LoginOptions): Promise<void>;
        callback(ctx: T): Promise<Authorization>;
        middleware(ctx: T, scopes?: string[]): void;
    };
}
export default Client;
