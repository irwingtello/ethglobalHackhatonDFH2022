import { DefaultIssuerResolver, DefaultWebFingerResolver, DefaultIPFSResolver } from '@uauth/common';
import { randomBytes, createHash } from 'crypto';
import jwt from 'jsonwebtoken';
import jwkToPem from 'jwk-to-pem';

const getRandomBytes = length => randomBytes(length);
const pkceMask = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_~.';

const generateCodeVerifier = length => {
  return Array.from(getRandomBytes(length)).map(v => pkceMask[v % pkceMask.length]).join('');
};

const generateCodeChallengeAndVerifier = async (length = 43, method = 'S256') => {
  const verifier = generateCodeVerifier(length);

  switch (method) {
    case 'plain':
      return {
        verifier,
        challenge: verifier
      };

    case 'S256':
      return {
        verifier,
        challenge: toUrlEncodedBase64(sha256(verifier))
      };

    default:
      throw new Error('bad challenge method');
  }
};
const sha256 = s => {
  return createHash('sha256').update(new TextEncoder().encode(s)).digest().buffer;
};
const toBase64 = buf => {
  return Buffer.from(buf).toString('base64');
};
const toUrlEncodedBase64 = buf => {
  return toBase64(buf).replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
};
new TextEncoder();
new TextDecoder();

const verifyIdToken = async (jwks_uri, jwks, id_token, nonce) => {
  let secretOrPublicKey;

  if (jwks_uri) {
    secretOrPublicKey = (header, cb) => {
      fetch(jwks_uri).then(res => res.json()).then(({
        keys
      }) => {
        const key = keys.find(k => k.kid === header.kid);

        if (key) {
          cb(null, jwkToPem(key));
          return;
        }

        throw new Error(`Unable to find a signing key that matches '${header.kid}'`);
      }).catch(cb);
    };
  } else {
    throw new Error('jwks not supported only jwks_uri');
  }

  const options = {};
  const idToken = await new Promise((resolve, reject) => {
    jwt.verify(id_token, secretOrPublicKey, options, (error, decoded) => {
      if (error) {
        reject(error);
      }

      resolve(decoded);
    });
  });
  idToken.__raw = id_token;

  if (nonce !== idToken.nonce) {
    throw new Error("nonces don't match");
  }

  return idToken;
};

class Client {
  constructor(options) {
    this.options = void 0;
    this.issuerResolver = void 0;
    options.fallbackIssuer = options.fallbackIssuer || 'https://auth.unstoppabledomains.com';
    options.scope = options.scope || 'openid';
    options.maxAge = options.maxAge || 600;
    options.clockSkew = options.clockSkew || 60;
    this.options = options; // eslint-disable-next-line @typescript-eslint/no-this-alias

    const self = this;
    this.issuerResolver = new DefaultIssuerResolver({
      webfingerResolver: new DefaultWebFingerResolver({
        ipfsResolver: new DefaultIPFSResolver((...args) => (this.options.createIpfsUrl || DefaultIPFSResolver.defaultCreateUrl)(...args)),
        domainResolver: {
          records(domain, keys) {
            return self.options.resolution.records(domain, keys);
          }

        }
      })
    });
  }

  createExpressSessionLogin(sessionKey = 'uauth', localsKey = 'uauth') {
    const {
      login,
      callback,
      middleware
    } = this.createLogin({
      storeInteraction: (ctx, interaction) => {
        ctx.req.session[sessionKey] = {
          interaction
        };
      },
      retrieveInteraction: ctx => {
        var _ctx$req$session$sess;

        return (_ctx$req$session$sess = ctx.req.session[sessionKey]) == null ? void 0 : _ctx$req$session$sess.interaction;
      },
      deleteInteraction: ctx => {
        delete ctx.req.session[sessionKey].interaction;
      },
      storeAuthorization: (ctx, authorization) => {
        ctx.req.session[sessionKey] = {
          uauth: authorization
        };
      },
      retrieveAuthorization: ctx => ctx.req.session[sessionKey].uauth,
      deleteAuthorization: ctx => {
        delete ctx.req.session[sessionKey].uauth;
      },
      retrieveAuthorizationEndpointResponse: ctx => ctx.req.body,
      passOnAuthorization: (ctx, authorization) => {
        ctx.res.locals[localsKey] = authorization;
        return ctx.next();
      },
      redirect: (ctx, url) => {
        ctx.res.redirect(url);
      }
    });
    return {
      login: (req, res, next, options) => login({
        req,
        res,
        next
      }, options),
      callback: (req, res, next) => callback({
        req,
        res,
        next
      }),
      middleware: (scopes = []) => (req, res, next) => middleware({
        req,
        res,
        next
      }, scopes)
    };
  }

  formatUrlSearchParams(endpoint, params) {
    const url = new URL(endpoint);
    url.search = new URLSearchParams(Object.entries(params).reduce((a, [k, v]) => {
      if (k && v) {
        a.push([k, v]);
      }

      return a;
    }, [])).toString();
    return url.toString();
  }

  async buildAuthorizationUrlAndInteraction(options) {
    const openidConfiguration = await this.issuerResolver.resolve(options.username, this.options.fallbackIssuer);

    if (!openidConfiguration.authorization_endpoint) {
      throw new Error('no authorization_endpoint');
    }

    const nonce = getRandomBytes(32).toString('base64');
    const state = getRandomBytes(32).toString('base64');
    const codeChallengeMethod = 'S256';
    const {
      verifier,
      challenge
    } = await generateCodeChallengeAndVerifier(43, codeChallengeMethod);
    const request = {
      client_id: this.options.clientID,
      login_hint: options.username,
      code_challenge: challenge,
      code_challenge_method: codeChallengeMethod,
      nonce,
      state,
      max_age: this.options.maxAge,
      resource: this.options.audience,
      redirect_uri: this.options.redirectUri,
      response_type: 'code',
      response_mode: 'form_post',
      scope: this.options.scope,
      prompt: 'login'
    };
    const interaction = {
      nonce,
      state,
      verifier,
      tokenEndpoint: openidConfiguration.token_endpoint,
      jwksUri: openidConfiguration.jwks_uri,
      jwks: openidConfiguration.jwks
    };
    return {
      url: this.formatUrlSearchParams(openidConfiguration.authorization_endpoint, request),
      interaction
    };
  }

  async authorizationCodeGrantExchange(interaction, authorizationEndpointResponse) {
    if (authorizationEndpointResponse.state !== interaction.state) {
      throw new Error('invalid state');
    }

    const tokenRequest = {
      client_id: this.options.clientID,
      client_secret: this.options.clientSecret,
      code: authorizationEndpointResponse.code,
      code_verifier: interaction.verifier,
      grant_type: 'authorization_code',
      redirect_uri: this.options.redirectUri
    };
    const tokenResponse = await fetch(interaction.tokenEndpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: new URLSearchParams(tokenRequest).toString()
    }).then(async resp => resp.ok ? resp.json() : Promise.reject(await resp.json()));
    const idToken = await verifyIdToken(interaction.jwksUri, interaction.jwks, tokenResponse.id_token, interaction.nonce); // Verifiy token

    const expiresAt = Date.now() + tokenResponse.expires_in * 1000;
    const authorization = {
      accessToken: tokenResponse.access_token,
      idToken,
      expiresAt,
      scope: tokenResponse.scope,
      audience: this.options.audience
    };
    return authorization;
  }

  validateAuthorization(authorization, scopes = []) {
    if (!authorization) {
      throw new Error('no authorization present');
    }

    if (authorization.audience && this.options.audience !== authorization.audience) {
      throw new Error('incorrect audience for token');
    }

    if (scopes.length > 0 && !authorization.scope.split(/\s+/).some(v => scopes.includes(v))) {
      throw new Error('scope not allowed');
    }

    if (authorization.expiresAt < Date.now()) {
      throw new Error('authorization has expired');
    }
  }

  createLogin(actions) {
    return {
      login: async (ctx, options) => {
        const {
          url,
          interaction
        } = await this.buildAuthorizationUrlAndInteraction(options);
        await actions.storeInteraction(ctx, interaction);

        if (typeof options.beforeRedirect === 'function') {
          await options.beforeRedirect(options, url);
        }

        return actions.redirect(ctx, url);
      },
      callback: async ctx => {
        const interaction = await actions.retrieveInteraction(ctx);

        if (!interaction) {
          throw new Error('no interaction');
        }

        await actions.deleteInteraction(ctx);
        const response = await actions.retrieveAuthorizationEndpointResponse(ctx);

        if (response.error) {
          throw new Error(`${response.error}: ${response.error_description}`);
        }

        const authorization = await this.authorizationCodeGrantExchange(interaction, response);
        await actions.storeAuthorization(ctx, authorization);
        return authorization;
      },
      middleware: async (ctx, scopes) => {
        const authorization = await actions.retrieveAuthorization(ctx);

        try {
          this.validateAuthorization(authorization, scopes);
        } catch (error) {
          await actions.deleteAuthorization(ctx);
          throw error;
        }

        return actions.passOnAuthorization(ctx, authorization);
      }
    };
  }

}

export { Client };
//# sourceMappingURL=index.module.js.map
